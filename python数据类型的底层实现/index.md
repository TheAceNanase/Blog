# Python数据类型的底层实现


## 字符串


根据维基百科定义：字符串是由零个或多个字符组成的有限序列。而在Python3中，它有着更明确的意思：字符串是由Unicode码点组成的不可变序列（Strings
 are immutable sequences of Unicode code points.），本质上是数组。

## 字典与集合

字典和集合能如此高效，和它们内部的数据结构密不可分。不同于其他数据结构，字典和集合的内部结构都是一张**哈希表**：
对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。
而对集合来说，哈希表内只存储单一的元素。


什么是哈希表，简单来说就是一张带索引和存储空间的表，对于任意可哈希对象，通过哈希索引的计算公式：hash(hashable)%k（对可哈希对象进行哈希计算，然后对结果进行取余运算），可将该对象映射为0到k-1之间的某个表索引，然后在该索引所对应的空间进行变量的存储/读取等操作。


字典是Python的一种可变、无序容器数据结构，它的元素以键值对的形式存在，键值唯一，它的特点搜索速度很快：数据量增加10000倍，搜索时间增加不到2倍；当数据量很大的时候，字典的搜索速度要比列表快成百上千倍。

* 插入：
	* 对键进行哈希和取余运算，得到一个哈希表的索引，如果该索引所对应的表地址空间为空，将键值对存入该地址空间；

* 更新：
	*对键进行哈希和取余运算，得到一个哈希表的索引，如果该索引所对应的地址空间中健与要更新的健一致，那么就更新该健所对应的值；

* 查询：
	* 对要查找的健进行哈希和取余运算，得到一个哈希表的索引，如果该索引所对应的地址空间中健与要查询的健一致，那么就将该键值对取出来；

* 扩容
	* 字典初始化的时候，会对应初始化一个有k个空间的表，等空间不够用的时候，系统就会自动扩容，这时候会对已经存在的键值对重新进行哈希取余运算（重新进行插入操作）保存到其它位置；

* 碰撞：
	* 有时候对于不同的键，经过哈希取余运算之后，得到的索引值一样，这时候怎么办？这时采用公开寻址的方式，运用固定的模式将键值对插入到其它的地址空间，比如线性寻址：如果第i个位置已经被使用，我们就看看第i+1个，第i+2个，第i+3个有没有被使用…直到找到一个空间或者对空间进行扩容。
	* 比如：我们想存储 {’小小‘：18}这个键值对，经过哈希和取余运算之后，我们发现，其对应的索引值是0，但是0所指向的空间已经被’小王‘占用了，这就是碰撞。怎么办呢？我们看看0+1对应的所以有没有被占用，如果没有，我们就把’小小‘放在索引1所对应的地址空间中。取的时候，也按照同样的规则，进行探查。

### 复杂度
|操作 | 操作说明| 时间复杂度|
| --- | --- | --- |
| copy | 复制 | O(n) |
| get(value) | 获取 | O(1) |
| set(value) | 修改 | O(1) |
| delete(value) | 删除 | O(1) |
| search(value) | 字典搜索 | O(1) |
| iterration(value) | 字典迭代 | O(n) |


## 列表


list 本质上是一个长度可变的连续**数组**。其中 ob_item 是一个指针列表，里边的每一个指针都指向列表中的元素，而 allocated 则用于存储该列表目前已被分配的空间大小。


*tuple 和 list 相似，本质也是一个数组，但是空间大小固定。不同于一般数组，Python 的 tuple 做了许多优化，来提升在程序中的效率。*


### 复杂度

|操作 | 操作说明| 时间复杂度|
| --- | --- | --- |
| a = index(value) | 索引赋值 | O(1) |
| index(value) | 查找list某个元素的索引 | O(1) |
| append(value) | 队尾添加 | O(1) |
| pop() | 队尾删除 | O(1) |
| pop(index) | 根据索引删除某个元素 | O(n) |
| insert(index, value) | 根据索引插入某个元素 | O(n) iterration |
| search(in) | 列表搜索（其实就是in关键字） | O(n) |
| slice [x:y] | 切片, 获取x, y为O(1), 获取x,y 中间的值为O(k) | O(k) |
| del slice [x:y] | 删除切片，删除切片后数据需要重新移动/合并 | O(n) |
| reverse | 列表反转 | O(n) |
| sort | 排序 | O(nlogn) |
