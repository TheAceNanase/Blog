# Python内存回收机制

 我们从三个方面来了解一下Python的垃圾回收机制。

## 一、引用计数
  Python垃圾回收主要以引用计数为主，分代回收为辅。引用计数法的原理是每个对象维护一个ob_ref，用来记录当前对象被引用的次数，也就是来追踪到底有多少引用指向了这个对象。
### 当发生以下四种情况的时候，该对象的引用计数器+1

* 对象被创建  a=14
* 对象被引用  b=a
* 对象被作为参数,传到函数中   func(a)
* 对象作为一个元素，存储在容器中   List={a,”a”,”b”,2}

### 当发生以下四种情况时，该对象的引用计数器-1

* 当该对象的别名被显式销毁时  del a
* 当该对象的引别名被赋予新的对象，   a=26
* 一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
* 将该元素从容器中删除时，或者容器被销毁时。

### 当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁

### 引用计数法有很明显的优点：

* 高效
* 运行期没有停顿 可以类比一下Ruby的垃圾回收机制，也就是 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。
* 对象有确定的生命周期
* 易于实现

### 原始的引用计数法也有明显的缺点：

* 维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。
* 无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。
循环引用的示例：

## 二、标记-清除
 针对循环引用的情况：我们有一个“孤岛”或是一组未使用的、互相指向的对象，但是谁都没有外部引用。换句话说，我们的程序不再使用这些节点对象了，所以我们希望Python的垃圾回收机制能够足够智能去释放这些对象并回收它们占用的内存空间。但是这不可能，因为所有的引用计数都是1而不是0。Python的引用计数算法不能够处理互相指向自己的对象。你的代码也许会在不经意间包含循环引用并且你并未意识到。事实上，当你的Python程序运行的时候它将会建立一定数量的“浮点数垃圾”，Python的GC不能够处理未使用的对象因为应用计数值不会到零。 

『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

## 三、分代回收
* 分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。
* Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代）
* 他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。
* 新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发
* 把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推
* 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。
